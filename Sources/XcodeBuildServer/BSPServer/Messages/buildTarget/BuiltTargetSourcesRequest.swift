//
//  BuiltTargetSourcesRequest.swift
//
//  Copyright Â© 2024 Wang Lun.
//

import Foundation

struct BuiltTargetSourcesRequest: RequestType, Sendable {
    static func method() -> String {
        "buildTarget/sources"
    }
    
    struct Params {
        let language: LanguageId?
        let isHeader: Bool?
    }

    func handle(handler: any MessageHandler, id: RequestID) async -> (any ResponseType)? {
        nil
    }
}

public struct BuildTargetSourcesResponse: ResponseType, Hashable {
    public var items: [SourcesItem]

    public init(items: [SourcesItem]) {
        self.items = items
    }
}

public struct SourcesItem: Codable, Hashable, Sendable {
    public var target: BuildTargetIdentifier

    /// The text documents and directories that belong to this build target.
    public var sources: [SourceItem]

    /// The root directories from where source files should be relativized.
    /// Example: ["file://Users/name/dev/metals/src/main/scala"]
    public var roots: [URI]?

    public init(target: BuildTargetIdentifier, sources: [SourceItem], roots: [URI]? = nil) {
        self.target = target
        self.sources = sources
        self.roots = roots
    }
}

public struct SourceItem: Codable, Hashable, Sendable {
    /// Either a text document or a directory. A directory entry must end with a
    /// forward slash "/" and a directory entry implies that every nested text
    /// document within the directory belongs to this source item.
    public var uri: URI

    /// Type of file of the source item, such as whether it is file or directory.
    public var kind: SourceItemKind

    /// Indicates if this source is automatically generated by the build and is
    /// not intended to be manually edited by the user.
    public var generated: Bool

    /// Kind of data to expect in the `data` field. If this field is not set, the kind of data is not specified.
    public var dataKind: SourceItemDataKind?

    /// Language-specific metadata about this source item.
    public var data: LSPAny?

    public init(
        uri: URI,
        kind: SourceItemKind,
        generated: Bool,
        dataKind: SourceItemDataKind? = nil,
        data: LSPAny? = nil
    ) {
        self.uri = uri
        self.kind = kind
        self.generated = generated
        self.dataKind = dataKind
        self.data = data
    }
}

public enum SourceItemKind: Int, Codable, Hashable, Sendable {
    /// The source item references a normal file.
    case file = 1

    /// The source item references a directory.
    case directory = 2
}

public struct SourceItemDataKind: RawRepresentable, Codable, Hashable, Sendable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue
    }

    /// `data` field must contain a JvmSourceItemData object.
    public static let jvm = SourceItemDataKind(rawValue: "jvm")

    /// `data` field must contain a `SourceKitSourceItemData` object.
    ///
    /// **(BSP Extension)**
    public static let sourceKit = SourceItemDataKind(rawValue: "sourceKit")
}

/// **(BSP Extension)**
public struct SourceKitSourceItemData: LSPAnyCodable, Codable {
    /// The language of the source file. If `nil`, the language is inferred from the file extension.
    public var language: Language?

    /// Whether the file is a header file that is clearly associated with one target.
    ///
    /// For example header files in SwiftPM projects are always associated to one target and SwiftPM can provide build
    /// settings for that header file.
    ///
    /// In general, build systems don't need to list all header files in the `buildTarget/sources` request: Semantic
    /// functionality for header files is usually provided by finding a main file that includes the header file and
    /// inferring build settings from it. Listing header files in `buildTarget/sources` allows SourceKit-LSP to provide
    /// semantic functionality for header files if they haven't been included by any main file.
    public var isHeader: Bool?

    public init(language: Language? = nil, isHeader: Bool? = nil) {
        self.language = language
        self.isHeader = isHeader
    }

    public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
        if case .string(let language) = dictionary[CodingKeys.language.stringValue] {
            self.language = Language(rawValue: language)
        }
        if case .bool(let isHeader) = dictionary[CodingKeys.isHeader.stringValue] {
            self.isHeader = isHeader
        }
    }

    public func encodeToLSPAny() -> LSPAny {
        var result: [String: LSPAny] = [:]
        if let language {
            result[CodingKeys.language.stringValue] = .string(language.rawValue)
        }
        if let isHeader {
            result[CodingKeys.isHeader.stringValue] = .bool(isHeader)
        }
        return .dictionary(result)
    }
}
