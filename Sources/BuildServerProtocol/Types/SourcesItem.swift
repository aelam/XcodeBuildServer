public struct SourcesItem: Codable, Hashable, Sendable {
    public var target: BSPBuildTargetIdentifier

    /// The text documents and directories that belong to this build target.
    public var sources: [SourceItem]

    /// The root directories from where source files should be relativized.
    /// Example: ["file://Users/name/dev/metals/src/main/scala"]
    public var roots: [URI]?

    public init(target: BSPBuildTargetIdentifier, sources: [SourceItem], roots: [URI]? = nil) {
        self.target = target
        self.sources = sources
        self.roots = roots
    }
}

public struct SourceItem: Codable, Hashable, Sendable {
    /// Either a text document or a directory. A directory entry must end with a
    /// forward slash "/" and a directory entry implies that every nested text
    /// document within the directory belongs to this source item.
    public var uri: URI

    /// Type of file of the source item, such as whether it is file or directory.
    public var kind: SourceItemKind

    /// Indicates if this source is automatically generated by the build and is
    /// not intended to be manually edited by the user.
    public var generated: Bool

    /// Kind of data to expect in the `data` field. If this field is not set, the kind of data is not specified.
    public var dataKind: SourceItemDataKind?

    /// Language-specific metadata about this source item.
    public var data: LSPAny?

    public init(
        uri: URI,
        kind: SourceItemKind,
        generated: Bool,
        dataKind: SourceItemDataKind? = nil,
        data: LSPAny? = nil
    ) {
        self.uri = uri
        self.kind = kind
        self.generated = generated
        self.dataKind = dataKind
        self.data = data
    }
}

public enum SourceItemKind: Int, Codable, Hashable, Sendable {
    /// The source item references a normal file.
    case file = 1

    /// The source item references a directory.
    case directory = 2
}

public struct SourceItemDataKind: RawRepresentable, Codable, Hashable, Sendable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue
    }

    /// `data` field must contain a JvmSourceItemData object.
    public static let jvm = SourceItemDataKind(rawValue: "jvm")

    /// `data` field must contain a `SourceKitSourceItemData` object.
    ///
    /// **(BSP Extension)**
    public static let sourceKit = SourceItemDataKind(rawValue: "sourceKit")
}

/// **(BSP Extension)**
public struct SourceKitSourceItemData: LSPAnyCodable, Codable {
    /// The language of the source file. If `nil`, the language is inferred from the file extension.
    public var language: Language?

    /// The kind of source file that this source item represents. If omitted, the item is assumed to be a normal source
    /// file, ie. omitting this key is equivalent to specifying it as `source`.
    public var kind: SourceKitSourceItemKind?

    /// The output path that is during indexing for this file, ie. the `-index-unit-output-path`, if it is specified
    /// in the compiler arguments or the file that is passed as `-o`, if `-index-unit-output-path` is not specified.
    ///
    /// This allows SourceKit-LSP to remove index entries for source files that are removed from a target but remain
    /// present on disk and to index a file that is part of multiple targets in the context of each target.
    ///
    /// The server communicates during the initialize handshake whether it populates this property by setting
    /// `outputPathsProvider: true` in `SourceKitInitializeBuildResponseData`.
    public var outputPath: String?

    public init(language: Language? = nil, kind: SourceKitSourceItemKind? = nil, outputPath: String? = nil) {
        self.language = language
        self.kind = kind
        self.outputPath = outputPath
    }

    public init?(fromLSPDictionary dictionary: [String: LSPAny]) {
        if case let .string(language) = dictionary[CodingKeys.language.stringValue] {
            self.language = Language(rawValue: language)
        }
        if case let .string(kind) = dictionary[CodingKeys.kind.stringValue] {
            self.kind = SourceKitSourceItemKind(rawValue: kind)
        }
        if case let .string(outputPath) = dictionary[CodingKeys.outputPath.stringValue] {
            self.outputPath = outputPath
        }
    }

    public func encodeToLSPAny() -> LSPAny {
        var result: [String: LSPAny] = [:]
        if let language {
            result[CodingKeys.language.stringValue] = .string(language.rawValue)
        }
        if let kind {
            result[CodingKeys.kind.stringValue] = .string(kind.rawValue)
        }
        if let outputPath {
            result[CodingKeys.outputPath.stringValue] = .string(outputPath)
        }
        return .dictionary(result)
    }
}

/// **(BSP Extension)**
public struct SourceKitSourceItemKind: RawRepresentable, Codable, Hashable, Sendable {
    public var rawValue: String

    public init(rawValue: String) {
        self.rawValue = rawValue
    }

    /// A normal source file.
    public static let source = SourceKitSourceItemKind(rawValue: "source")

    /// A header file.
    public static let header = SourceKitSourceItemKind(rawValue: "header")

    /// A DocC catalog.
    public static let doccCatalog = SourceKitSourceItemKind(rawValue: "doccCatalog")
}
